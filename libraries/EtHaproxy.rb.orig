module EtHaproxy
  module Helpers
<<<<<<< HEAD

    def string_acls(acls)
      acls.map{|a| a.join(' ') }.join(' or ')
    end

    def trusted_ips( trusted_network_obj )

=======
    def trusted_ips(trusted_network_obj)
>>>>>>> 2e23674c2abce530c78d54f75e0ce971792ce4fc
      require 'ipaddress'

      ips = {}

      trusted_network_obj.each do |set, nets|
        if set != 'id'
          ips[set] = [] if !ips[set]
          nets.each do |n_obj|
            case n_obj
            when String
              n = n_obj
            when Hash || Mash
              n = n_obj['network']
            else
              fail "Unrecognized trusted network type: #{n_obj.class}/#{n_obj.inspect}"
            end

            ips[set] += IPAddress(n).map { |net|
              net.address
            }
          end
        end
      end

      ips
    end

    def trusted_networks(trusted_network_obj)
      networks = {}

      trusted_network_obj.reject { |set, nets| set == 'id' }.each do |set, nets|
        networks[set] = nets.map do |n_obj|
          case n_obj
          when String
            n_obj
          when Hash || Mash
            n_obj['network']
          else
            fail "Unrecognized trusted network type: #{n_obj.class}/#{n_obj.inspect}"
          end
        end
      end

      networks
    end

    def eips(aws_api_user)
      require 'fog'

      aws_keys = Chef::EncryptedDataBagItem.load('secrets', 'aws_credentials')[aws_api_user]

      conn = Fog::Compute.new(
        provider: 'AWS',
        aws_access_key_id: aws_keys['access_key_id'],
        aws_secret_access_key: aws_keys['secret_access_key']
      )

      conn.addresses.map { |a|
        a.public_ip
      }
    end

    def instance_ext_ips(aws_api_user)
      require 'fog'

      aws_keys = Chef::EncryptedDataBagItem.load('secrets', 'aws_credentials')[aws_api_user]

      conn = Fog::Compute.new(
        provider: 'AWS',
        aws_access_key_id: aws_keys['access_key_id'],
        aws_secret_access_key: aws_keys['secret_access_key']
      )

      conn.servers.select{ |s|
        s.public_ip_address
      }.map{ |s|
        s.public_ip_address
      }
    end

    def nodes_for_recipes(env, backends)
      recipes = backends.select { |be, be_conf|
        be_conf['servers_recipe']
      }.map { |be, be_conf|
        be_conf['servers_recipe']
      }

      recipe_search_string = recipes.map { |r| 'recipes:' + r.gsub(':', '\:') }.join(' OR ')

      clusters = {}

      recipes.each do |rec|
        clusters[rec] = []
      end

      r = Chef::Search::Query.new.search(:node, "chef_environment:#{env} AND (#{recipe_search_string})").first

      r.each do |n|
        cluster_recipe = (recipes & n.recipes).first
        clusters[cluster_recipe] << n
      end

      clusters
    end

<<<<<<< HEAD
    def server_line(conf, be_conf)
      servername = conf.name || conf['name']
      hostname = conf['ipaddress'] || conf['fqdn']
      port = conf['port'] || be_conf['port']

      output = "server #{servername} #{hostname}:#{port}"

      if be_conf['check_req'] &&
        be_conf['check_req']['always'] ||
        (be_conf['servers_recipe'] &&
          @recipe_servers[be_conf['servers_recipe']].count > 1)

        output += ' check'
      end

      output += ' ' + conf['options'].join(' ') if conf['options']
      output += ' ' + be_conf['server_options'].join(' ') if be_conf['server_options']

      output
    end

    def backend_clause(name, conf)
      lines = []
      lines << 'backend ' + name
      unless conf['mode'] && conf['mode'] == 'tcp'
        lines << '  cookie ' + conf['cookie_prefix'] + ' prefix' if conf['cookie_prefix']
        lines << '  cookie ' + conf['cookie_insert'] + ' insert indirect' if conf['cookie_insert']
        if conf['check_req'] && conf['check_req']['method']
          line = '  option httpchk ' + conf['check_req']['method']
          line += ' ' + conf['check_req']['url'] if conf['check_req']['url']
          lines << line
        end
      end

      if conf['servers']
        conf['servers'].each do |server|
          lines << '  ' + server_line(
            server,
            conf
          )
        end
      end

      if conf['servers_recipe']
        fail "In order to use the servers_recipe clause, you also need " +
          "to define 'port' for the entire backend." unless conf["port"]
        unless @recipe_servers[conf['servers_recipe']] &&
          @recipe_servers[conf['servers_recipe']] != []
          Chef::Log.warn "Recipe #{conf['servers_recipe']} does not " +
            "appear to have any associated servers"
        else
          @recipe_servers[conf['servers_recipe']].each do |server|
            lines << '  ' + server_line(
              server,
              conf
            )
          end
        end
      end
      lines
    end

    def gen_ssl_redirects(applications,acls)
=======
    def gen_ssl_redirects(applications, acls)
      ssl_redirects = []
>>>>>>> 2e23674c2abce530c78d54f75e0ce971792ce4fc

      applications.each do |app, app_conf|
        if app_conf['ssl_required']

          # The logic here is inverted so that we can keep 'false' as the default
          # behavior instead of requiring that all applications specify this
          # option.  It also helps make the template more readable.
          if app_conf['ssl_disable_redirect']
            Chef::Log.debug "App: #{app}, Redirect permitted: no"
            redirect_permitted = false
          else
            Chef::Log.debug "App: #{app}, Redirect permitted: yes"
            redirect_permitted = true
          end

          # Janky method of finding the actual hostname/fqdn of the request
          # and using it in the redirect.  Note that it doesn't handle
          # the eventuality of regex-based ACLs very well at all.

          app_endpoint_host_acl = app_conf['acls'].flatten.select { |a|
            a !~ /^!/ &&
              acls[a]['type'] == 'hdr_beg(host)'
          }.first

          app_endpoint_host = acls[app_endpoint_host_acl]['match']

          ssl_redirects << {
            'acls' => app_conf['acls'],
            'fqdn' => app_endpoint_host,
            'redirect_permitted' => redirect_permitted
          }

          if app_conf['endpoint']
            ssl_redirects << {
              'acls' => [["host_endpoint_#{app}"]],
              'fqdn' => app_conf['endpoint'],
              'redirect_permitted' => redirect_permitted
            }
          end # if app_conf['endpoint']
        end # if ssl_required
      end # node['haproxy']['applications'].each

<<<<<<< HEAD
      ssl_redirects.uniq.map do |ssl_redirect|
        output = ''
        if ssl_redirect['redirect_permitted'] == true
          output = 'redirect prefix https://' + ssl_redirect['fqdn']
        else
          output = 'block'
        end
        output += ' if ' + string_acls(ssl_redirect['acls'])
        output
      end

=======
      ssl_redirects.uniq
>>>>>>> 2e23674c2abce530c78d54f75e0ce971792ce4fc
    end # def
  end
end
